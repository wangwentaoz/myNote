1. 插件
   1. TypeScript Import
      1. 收集项目中所有的类型定义，敲：时进行类型补全
   2. Move TS
      1. 通过右键文件，选择move ts，之后编辑文件路径，直接修改项目的文件结构，并更新在其他文件中对这个文件的导入import
   3. vscode 内置配置项
      1. 点击设置，选择workspace设置，在extension中选择TypeScript
      2. 推荐开启的几个配置项，inlay hints 相关代码提示
         1. function like return types  显示推导得到的函数返回值类型
         2. parameter names  显示函数入参名称
         3. parameter types  显示函数入参类型
         4. variable types  显示变量类型
2. ts文件的快速执行： ts-node 与 ts-node-dev
   1. 直接执行ts文件并且监听文件重新执行
   2. 安装：npm i ts-node typescript -g
   3. 创建typescript的项目配置文件：tsconfig.json
      1. npx typescript --init
      2. tsc --init
3. 类型兼容性检查
   1. 我们在进行类型比较时，需要使用一个具有具体类型的变量与一个类型进行赋值操作。
      1. 在只是想要进行类型比较的前提下，并没有必要去声明两个真实的变量，即涉及了值空间操作。
      2. 我们完全可以只在类型空间(用于存放typescript类型信息的内存空间)比较这些类型，只需要使用declare关键字
          ```
          interface Foo{
            name: string;
          }
          interface Bar{
            name: string;
            job:string;
          }
          declare let foo:Foo;
          declare let bar:Bar;
          foo = bar
          ```
         1. 可以理解为声明真实的变量时，我们使用一个值空间存放这个变量具体的属性，一个类型空间存放这个变量的类型
         2. 通过declare关键字，我们声明了一个仅在类型空间存放的变量，它在运行时完全不存在，避免了繁琐的属性声明
   2. 对于类型兼容性的检查除了可以使用两两声明然后赋值外，还可以通过工具类型的形式，例如tsd这个npm包提供的一系列工具类型，帮助进行声明式的类型检查：
      ```
      import { expectType } from 'tsd'
      expectType<string>('wang')    错误
      expectType<string>(999)       正确
      ```
      1. 它的结构大致是：expectType<预期的类型>(表达式或者变量)，除了expectType(检查预期类型与表达式或变量的类型是否一致)
      2. tsd还提供了expectNotType(检查预期类型与表达式或变量的类型是否不同)
      3. expectAssignable(检查表达式或变量的类型是否能赋值给预期类型)
4. 原始类型的类型标注
   1. JavaScript的内置原始类型
      1. number / string / boolean / null / undefined / symbol / bigint
      2. 除了 null 与 undefined 以外，余下的类型基本上可以完全对应到 JavaScript 中的数据类型概念
   2. null 与 undefined
      1. 在 JavaScript 中，null 与 undefined 分别表示“这里有值，但是个空值”和“这里没有值”
      2. 而在 TypeScript 中，null 与 undefined 类型都是有具体意义的类型
         1. 也就是说，它们作为类型时，表示的是一个有意义的具体类型值
         2. 这两者在没有开启 strictNullChecks 检查的情况下，会被视作其他类型的子类型，比如 string 类型会被认为包含了 null 与 undefined 类型
   3. 在 TypeScript 中还存在着一个特殊的类型：void，它和 JavaScript 中的 void 同样不是一回事
      1. JavaScript 
         1. void(0) 等价于 void 0，即 void expression 的语法
         2. void 操作符会执行后面跟着的表达式并返回一个 undefined，如你可以使用它来执行一个立即执行函数（IIFE）
           ```
           void function iife() {
             console.log("Invoked!");
           }();
           ```
         3. void 操作符强制将后面的函数声明转化为了表达式，因此整体其实相当于：void((function iife(){})())
      2. TypeScript   
         1. TypeScript的 void 用于描述一个内部没有 return 语句，或者没有显式 return 一个值的函数的返回值
           ```
            function func1() {}
            function func2() {
              return;
            }
            function func3() {
              return undefined;
            }
           ```
            1. 在这里，func1 与 func2 的返回值类型都会被隐式推导为 void
            2. 只有显式返回了 undefined 值的 func3 其返回值类型才被推导为了 undefined
            3. 但在实际的代码执行中，func1 与 func2 的返回值均是 undefined
            4. 虽然 func3 的返回值类型会被推导为 undefined，但是你仍然可以使用 void 类型进行标注，因为在类型层面 func1、func2、func3 都表示“没有返回一个有意义的值”
         2. 可以认为 void 表示一个空类型，而 null 与 undefined 都是一个具有意义的实际类型（注意与它们在 JavaScript 中的意义区分）
         3. 而 undefined 能够被赋值给 void 类型的变量，就像在 JavaScript 中一个没有返回值的函数会默认返回一个 undefined
         4. null 类型也可以，但需要在关闭 strictNullChecks 配置的情况下才能成立
           ```
            const voidVar1: void = undefined;
            const voidVar2: void = null; // 需要关闭 strictNullChecks
           ```
5. 数组的类型标注
   1. 在 TypeScript 中有两种方式来声明一个数组类型：
      ```
      const arr1: string[] = [];
      const arr2: Array<string> = [];
      ```
   2. 