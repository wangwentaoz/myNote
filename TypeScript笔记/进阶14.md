1. 上一节，我们了解了模板字符串类型的基础内容，它与数个类型工具的协作，以及将作为本节核心内容的，模板字符串类型与模式匹配产生的化学反应
   1. 我们在上一节说到，对模板字符串类型中使用模式匹配时，本质上就是在一个字符串字面量类型结构做处理
   2. 因此我们可以复刻一个字符串类型的值拥有的大部分方法，从 trim 到 split，从 startsWith 到 endsWith 等等
   3. 这些方法就是我们本节要学习的内容，从简单的 trim 、includes，到需要稍微绕一绕的 split、join ，再到较为复杂的 case 转换，我们都将一一实现
2. 从最简单的模式匹配说起：Trim、Includes 等
   1. 最简单的模式匹配只有一层条件类型语句，也就意味着我们不需要对模式匹配的结果做结构转换等操作。对比到字符串类型变量的方法，也就是 trim（trimLeft、trimRight）、includes、startsWith 与 endsWith
   2. 我们从比较有代表性的 includes 看起，对应实现一个类型层面的版本：判断传入的字符串字面量类型中是否含有某个字符串：
      ```
      type Include<
        Str extends string,
        Search extends string
      > = Str extends `${infer _R1}${Search}${infer _R2}` ? true : false;
      ```
      1. 在 Include 类型中，我们在 Search 前后声明了两个 infer 插槽，但实际上并不消费 R1 与 R2，而只是判断字符串是否可以被划分为要搜索的部分 + 其他部分。来验证一下实际效果：
        ```
        type IncludeRes1 = Include<'linbudu', 'lin'>; // true
        type IncludeRes2 = Include<'linbudu', '_lin'>; // false
        type IncludeRes3 = Include<'linbudu', ''>; // true
        type IncludeRes4 = Include<' ', ''>; // true
        type IncludeRes5 = Include<'', ''>; // false
        ```
      2. 在 IncludeRes4 中，我们发现对于空字符串 '' 需要进行特殊的处理，''.includes('') 也应当是成立的，就像实际字符串中进行判断一样。我们希望尽可能贴近原本字符串方法的表现，因此我们需要新增额外处理：
        ```
        type _Include<
          Str extends string,
          Search extends string
        > = Str extends `${infer _R1}${Search}${infer _R2}` ? true : false;

        type Include<Str extends string, Search extends string> = Str extends ''
          ? Search extends ''
            ? true
            : false
          : _Include<Str, Search>;
        ```
      3. 当字符串 Str 为空字符串时，我们判断 Search 是否是空字符串来直接决定返回结果，因为很明显 ''.includes('linbudu') 是不成立的。在 Str 不为空字符串时，我们才会真的进行 Include 的判断
      4. 在 Str 与 Search 均为空字符串的情况下，我们直接返回 true，否则我们才进行模式匹配
   3. 而提到模板字符串类型中的空字符串，我们会想到 trim 三兄弟：去除起始部分空格的 trimStart，去除结尾部分空格的 trimEnd，以及开头结尾空格一起去的 trim。基于模式匹配的思路我们还是很容易进行对应的类型实现：
      ```
      // trimStart
      type TrimLeft<V extends string> = V extends ` ${infer R}` ? R : V;

      // trimEnd
      type TrimRight<V extends string> = V extends `${infer R} ` ? R : V;

      // trim
      type Trim<V extends string> = TrimLeft<TrimRight<V>>;
      ```
      1. 聪明的你肯定会想到，我们的字符串边缘可能不止有一个空格！而这里的实现只能去掉一个，操作很简单，我们递归一下就好了：
        ```
        type TrimLeft<Str extends string> = Str extends ` ${infer R}` ? TrimLeft<R> : Str;

        type TrimRight<Str extends string> = Str extends `${infer R} ` ? TrimRight<R> : Str;

        type Trim<Str extends string> = TrimLeft<TrimRight<Str>>;
        ```
      2. 这样，在字符串的两边不包含空格时，递归就会停止，从而返回一致“干净”的字符串
      3. 而类型版本的 StartsWith 与 EndsWith 两个工具类型，和 Include 的实现非常接近，我们直接看其中 StartsWith 的最终实现与验证：
        ```
        type _StartsWith<
          Str extends string,
          Search extends string
        > = Str extends `${Search}${infer _R}` ? true : false;

        type StartsWith<Str extends string, Search extends string> = Str extends ''
          ? Search extends ''
            ? true
            : _StartsWith<Str, Search>
          : _StartsWith<Str, Search>;

        type StartsWithRes1 = StartsWith<'linbudu', 'lin'>; // true
        type StartsWithRes2 = StartsWith<'linbudu', ''>; // true
        type StartsWithRes3 = StartsWith<'linbudu', ' '>; // false
        type StartsWithRes4 = StartsWith<'', ''>; // true
        type StartsWithRes5 = StartsWith<' ', ''>; // true
        ```
      4. 和 Include 基本一致，只是我们需要确保 Search 在字符串的开头部分
      5. 在这一部分，我们了解了字符串类型中 Include、Trim 系列、StartsWith 与 EndsWith 这几个较简单的工具类型实现。现在热身完毕，是时候开始更复杂的部分了，比如 Replace 怎么样？
3. 结构转换：Replace、Split 与 Join
   1. 