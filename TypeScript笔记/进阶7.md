1. 结构化类型系统
   1. 在 TypeScript 中，你可能遇见过以下这样“看起来不太对，但竟然能正常运行”的代码：
      ```
      class Cat {
        eat() { }
      }
      class Dog {
        eat() { }
      }

      function feedCat(cat: Cat) { }
      feedCat(new Dog())
      ```
      1. 这里的 feedCat 函数明明需要的是一只猫，可为什么上传一只狗也可以呢？
      2. 如果我们为 Cat 类新增一个独特的方法，这个时候的表现才是符合预期的，即我们只能用真实的 Cat 类来进行调用：
      ```
      class Cat {
        meow() { }
        eat() { }
      }

      class Dog {
        eat() { }
      }

      function feedCat(cat: Cat) { }

      // 报错！
      feedCat(new Dog())
      ```
      3. 这是因为，TypeScript 比较两个类型并非通过类型的名称（即 feedCat 函数只能通过 Cat 类型调用），而是比较这两个类型上实际拥有的属性与方法
      4. 