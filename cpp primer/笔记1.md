# 2.3.2
1. std
   1. std::指出名字cout 和 endl 是定义在名为std 的命名空间(namespace)中，标准库定义的所有名字都在命名空间 std中
   2. 通过命名空间使用标准库有一个副作用:
      1. 当使用标准库中的一个名字时，必须显式说明我们想使用来自命名空间std中的名字
      2. 例如，需要写出std::cout，通过使用作用域运算符(::)来指出我们想使用定义在命名空间std中的名字cout
2. 变量和基本类型
   1. 字符和字符串字面值
      1. 由单引号括起来的称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值
      2. 字符串型字面值的类型实际上是由常量字符串的结尾添加一个空字符'\0'，因此其实际长度应该比内容+1
      3. 如果两个字符串字面值相邻，并且仅有缩进、空格、换行符分割，则他们实际上是一个整体
   2. 初始值
      1. 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象当前的值擦除，而已一个新值替代
      2. 列表初始化：用花括号来初始化变量，例 int a = {0}
         1. 特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错
         2. 比如把double类型变量赋值给int类型变量，正常不会报错，但是使用列表初始化就会报错
   3. 定义于函数体内部的内置类型的对象如果没有初始化，则其值未定义
      1. 类的对象如果没有显示的初始化，则其值由类决定
   4. 为了支持分离式编译，c++将声明和定义区分开
      1. 声明使程序的名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明
      2. 而定义负责创建与名字相关的实体
      3. 变量声明规定了变量的类型和名字，定义除此之外还申请了存储空间，也可能会为变量赋一个初始值
      4. 如果想声明而非定义，就要在变量名字前添加关键字extern，例如 extern int j;
      5. 变量能且只能被定义一次，但是可以多次声明
      6. 如果要在多个文件中使用同一个变量，就必须将声明和定义分离，此时变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝不能重复定义
   5. 复合类型
      1. 引用（左值引用）
         1. 引用为对象起了另外一个名字，引用类型 引用 另一种类型
            ```
            int ival = 0
            int &refVal = ival   // refVal 指向 ival
            int &refVal          // 报错：引用必须初始化
            ```
         2. 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。
         3. 一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化
         4. 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的
         5. 引用只能绑定到对象上，而不能与某个字面值或某个表达式的结算结果绑定在一起
      2. 指针
         1. 指针是指向另外一种类型的复合类型，实现了对其他对象的间接访问
         2. 与引用不同之处
            1. 指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
            2. 指针无需在定义时赋初值，和其他内置类型一样，如果在块级作用域内没有被初始化，也将拥有一个不确定的值
            3. 引用不是对象，没有实际地址，所以不能定义指向引用的指针
         3. 使用
            ```
            int ival = 42
            int *p = &ival  // p存放的是ival的地址，p是指向ival的指针
            cout << *p      // 由符号*（解引用符）得到指针p所指的对象，输出42
            *p = 0          // 由符号*得到指针p所指的对象，即可经由p为变量ival赋值
            cout << *p      // 输出 0
            ```
            1. 声明携程*p的形式，取值时需要用到取地址符&
         4. 指针值
            1. 指向一个对象
            2. 指向紧邻对象所占空间的下一个位置
            3. 空指针，意味着指针没有指向任何对象
            4. 无效指针，也就是上述情况之外的其他值
               1. 试图拷贝或以其他方式访问无效指针的值都将引发错误，编译器无法检查这种错误
               2. 第二第三种指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许
         5. 空指针
            1. 空指针不指向任意对象，在试图使用任何一个指针前可以检查它是否为空
            2. 声明空指针
              ```
              int *p1 = nullptr          // 等价于 int *p1 = 0 
              int *p2 = 0                // 直接将p2初始化为字面常量0
              // 首先需要 #include cstdlib
              int *p3 = NULL             // 等价于 int *p3 = 0 ，头文件cstdlib中将 预处理变量NULL 处理为 0
              ```
               1. 最直接的方法就是使用字面值 nullptr 来初始化指针
               2. 预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无需在前面加上std
            3. 把int变量直接赋值给指针是错误的操作，即使int变量的值恰好等于0也不行
            4. 建议初始化所有指针
         6. void* 指针
            1. void* 是一种特殊的指针，可用于存放任意对象的地址，我们对于改地址中到底是什么类型的对象并不了解
            2. 利用void*指针能做的事情比较有限
               1. 拿他和别的指针比较
               2. 作为函数的输入输出
               3. 赋给另外一个void*指针
            3. 不能直接操作void*指针所指向的对象，因为我们并不知道这个对象是什么类型
         7. 指向指针的指针
            1. 通过 * 的个数可以区分指针的级别，也就是说 ** 表示指向指针的指针， *** 表示指向指针的指针的指针
              ```
              int ival = 1024;   
              int *pi = &ival;   
              int **ppi = &pi;   // ppi指向一个int型的指针
              ```
         8. 指向指针的引用
            ```
            int i = 42;
            int *p;          // p是一个int型的指针
            int *&r = p;     // r是一个对指针p的引用
            r = &i;          // r引用了一个指针，因此r赋值给&i就是令p指向i
            *r = 0           // 解引用r得到i，也就是p指向的对象，将i的值改为0
            ``` 
   6. 