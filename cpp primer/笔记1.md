# 2.3.2
1. std
   1. std::指出名字cout 和 endl 是定义在名为std 的命名空间(namespace)中，标准库定义的所有名字都在命名空间 std中
   2. 通过命名空间使用标准库有一个副作用:
      1. 当使用标准库中的一个名字时，必须显式说明我们想使用来自命名空间std中的名字
      2. 例如，需要写出std::cout，通过使用作用域运算符(::)来指出我们想使用定义在命名空间std中的名字cout
2. 变量和基本类型
   1. 字符和字符串字面值
      1. 由单引号括起来的称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值
      2. 字符串型字面值的类型实际上是由常量字符串的结尾添加一个空字符'\0'，因此其实际长度应该比内容+1
      3. 如果两个字符串字面值相邻，并且仅有缩进、空格、换行符分割，则他们实际上是一个整体
   2. 初始值
      1. 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象当前的值擦除，而已一个新值替代
      2. 列表初始化：用花括号来初始化变量，例 int a = {0}
         1. 特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错
         2. 比如把double类型变量赋值给int类型变量，正常不会报错，但是使用列表初始化就会报错
   3. 定义于函数体内部的内置类型的对象如果没有初始化，则其值未定义
      1. 类的对象如果没有显示的初始化，则其值由类决定
   4. 为了支持分离式编译，c++将声明和定义区分开
      1. 声明使程序的名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明
      2. 而定义负责创建与名字相关的实体
      3. 变量声明规定了变量的类型和名字，定义除此之外还申请了存储空间，也可能会为变量赋一个初始值
      4. 如果想声明而非定义，就要在变量名字前添加关键字extern，例如 extern int j;
      5. 变量能且只能被定义一次，但是可以多次声明
      6. 如果要在多个文件中使用同一个变量，就必须将声明和定义分离，此时变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝不能重复定义
   5. 复合类型
      1. 引用（左值引用）
         1. 引用为对象起了另外一个名字，引用类型 引用 另一种类型
            ```
            int ival = 0
            int &refVal = ival   // refVal 指向 ival
            int &refVal          // 报错：引用必须初始化
            ```
         2. 一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。
         3. 一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化
         4. 定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的
         5. 引用只能绑定到对象上，而不能与某个字面值或某个表达式的结算结果绑定在一起
      2. 指针
         1. 指针是指向另外一种类型的复合类型，实现了对其他对象的间接访问
         2. 与引用不同之处
            1. 指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
            2. 指针无需在定义时赋初值，和其他内置类型一样，如果在块级作用域内没有被初始化，也将拥有一个不确定的值
            3. 引用不是对象，没有实际地址，所以不能定义指向引用的指针
         3. 使用
            ```
            int ival = 42
            int *p = &ival  // p存放的是ival的地址，p是指向ival的指针
            cout << *p      // 由符号*（解引用符）得到指针p所指的对象，输出42
            *p = 0          // 由符号*得到指针p所指的对象，即可经由p为变量ival赋值
            cout << *p      // 输出 0
            ```
            1. 声明携程*p的形式，取值时需要用到取地址符&
         4. 指针值
            1. 指向一个对象
            2. 指向紧邻对象所占空间的下一个位置
            3. 空指针，意味着指针没有指向任何对象
            4. 无效指针，也就是上述情况之外的其他值
               1. 试图拷贝或以其他方式访问无效指针的值都将引发错误，编译器无法检查这种错误
               2. 第二第三种指针没有指向任何具体对象，所以试图访问此类指针对象的行为不被允许
         5. 空指针
            1. 空指针不指向任意对象，在试图使用任何一个指针前可以检查它是否为空
            2. 声明空指针
              ```
              int *p1 = nullptr          // 等价于 int *p1 = 0 
              int *p2 = 0                // 直接将p2初始化为字面常量0
              // 首先需要 #include cstdlib
              int *p3 = NULL             // 等价于 int *p3 = 0 ，头文件cstdlib中将 预处理变量NULL 处理为 0
              ```
               1. 最直接的方法就是使用字面值 nullptr 来初始化指针
               2. 预处理变量不属于命名空间std，它由预处理器负责管理，因此我们可以直接使用预处理变量而无需在前面加上std
            3. 把int变量直接赋值给指针是错误的操作，即使int变量的值恰好等于0也不行
            4. 建议初始化所有指针
         6. void* 指针
            1. void* 是一种特殊的指针，可用于存放任意对象的地址，我们对于改地址中到底是什么类型的对象并不了解
            2. 利用void*指针能做的事情比较有限
               1. 拿他和别的指针比较
               2. 作为函数的输入输出
               3. 赋给另外一个void*指针
            3. 不能直接操作void*指针所指向的对象，因为我们并不知道这个对象是什么类型
         7. 指向指针的指针
            1. 通过 * 的个数可以区分指针的级别，也就是说 ** 表示指向指针的指针， *** 表示指向指针的指针的指针
              ```
              int ival = 1024;   
              int *pi = &ival;   
              int **ppi = &pi;   // ppi指向一个int型的指针
              ```
         8. 指向指针的引用
            ```
            int i = 42;
            int *p;          // p是一个int型的指针
            int *&r = p;     // r是一个对指针p的引用
            r = &i;          // r引用了一个指针，因此r赋值给&i就是令p指向i
            *r = 0           // 解引用r得到i，也就是p指向的对象，将i的值改为0
            ``` 
   6. const
      1. 默认状态下，const对象仅在文件内有效
         1. 编译器将在所有用到该变量的地方都替换成对应的值
         2. 当多个文件中出现同名的const变量时，其实等于在不同的文件中分别定义了独立的变量
      2. 当需要在文件中共享const变量时，即只在一个文件中定义const，而在其他多个文件中声明并使用它
         1. 解决：对const变量不论是声明还是定义都添加extern关键字，这时只需要定义一次就好
            ``` 
            file_1.cc 定义并初始化一个常量，该常量能被其他文件访问 
            extern const int bufSize = fcn()
            file_1.h  头文件
            extern const int bufSize // 与file_1.cc文件中定义的是同一个变量bufSize
            ``` 
         2. 因为bufSize是一个常量，必须使用extern加以限定使其被其他文件使用
         3. file_1.h  头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现
      3. const的引用
          ```
          const int ci = 1024
          const int &rl = ci
          rl = 42  // 错误，rl是对常量的引用
          int &r2 = ci // 错误，试图让一个非常量引用指向一个常量对象
          ```
         1. 把引用绑定到const对象上，称之为对常量的引用
         2. 不同之处是 其不能被用作修改它所绑定的对象，但是通过其他途径依然可以正常修改
      4. 引用的类型必须与其所引用的类型一致，存在两个例外
         1. 初始化常量引用时允许使用任意表达式作为初始值，只要改表达式可以转化为引用的类型
            ```
            int i = 42
            const int &r1 = i
            const int &r2 = 42
            const int &r3 = r1 * 2
            int &r4 = r1 * 2         // 错误，r4是一个普通的非常量引用
            ```
      5. 指针和const
         1. 指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能用指向常量的指针
      6. 指针的类型必须与其所引用的类型一致，存在两个例外
         1. 允许令一个指向常量的指针指向一个非常量对象
            ```
            double dval = 3.14
            const double *cptr = &dval        // 正确，但是不能通过cptr改变dval的值
            ```
         2. 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量
            1. 指向常量的指针仅仅要求不能通过该指针改变对象的值
            2. 没有规定那个对象的值不能通过其他途径改变
      7. const指针
         1. 指针是对象引用却不是，所以允许把指针本身定为常量
         2. 常量指针必须初始化，一旦初始化完成则其值（也就是存放在指针中的那个地址）就不能再改变了
         3. 把*放在const关键字前说明指针是一个常量，不变的是指针本身而不是指向的那个值
            ```
            int errNumb = 0;
            int *const curErr = &errNumb;         // curErr将一直指向errNumb，可以用curErr修改errNumb的值
            cosnt double pi = 3.14; 
            const double *const pip = &pi;        // pip是一个指向常量对象的常量指针，不论是pip所指的对象值还是pip自己存储的那个地址都不能改变
            ```
         4. 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值
      8. 顶层const
         1. 顶层const表示指针本身是个常量，底层const表示指针所指的对象是一个常量
            ```
            int *const p1 = &i    // 顶层const
            const int *p2 = &i    // 低层const
            ```
         2. 顶层const可以表示任意的对象是常量，底层const则与指针和引用等复合类型的基本类型有关
         3. 当执行对象拷贝操作时，拷入和拷出的对象必须具有相同底层const资格，或者两个对象的数据类型必须能够转换
      9. 常量表达式
         1. 指值不会改变并且在编译过程就能得到计算结果的表达式
         2. 字面值、用常量表达式初始化的const对象 都属于常量
            ```
            const int max_file = 20;              // 是常量表达式
            const int limit = max_file + 1;       // 是常量表达式
            const int sz = get_size();            // 不是常量表达式，具体值需要等到运行时才能获取到
            ```
      10. constexpr 变量
          1. C++11 新标准规定，允许将变量声明为constexpr类型以便由编译器验证变量的值是否是一个常量表达式
          2. 声明为constexpr的变量一定是一个常量，而且必须使用常量表达式初始化
            ```
            constexpr int mf = 20;                // 20 是常量表达式
            constexpr int limit = mf + 1;         // mf + 1 是常量表达式
            constexpr int mf = size();            // 只有当size是一个constexpr函数时才是一条正确的声明语句
            ```
          3. 新标准允许定义一种特殊的constexpr函数，这种函数足够简单以使得编译时就可以计算其结果，这样就可以用constexpr函数去初始化constexpr变量了
          4. 因为常量表达式的值需要在编译时就得到计算，所以需要对声明constexpr时用到的类型有所限制，这些类型被称为“字面值类型”
             1. 算数类型、引用、指针都属于字面值类型
             2. 自定义类、IO库、string类型都不属于字面值类型
             3. constexpr指针的初始值必须是nullptr或者0，或者存储于某个固定地址中的对象
             4. 函数体中定义的变量一般来说并没有存放在固定地址中，因此constexpr指针不能指向这样的变量
             5. 允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址，因此这样的变量可以被绑定
          5. 指针和constexpr
             1. 在constexpr声明中如果定义了一个指针，限定符constexpr仅针对指针有效，与指针所指的对象无关
                ```
                const int *p = nullptr;         // p是指向整型常量的指针
                constexpr int *q = nullptr;     // q是指向整数的常量指针
                ```
             2. constexpr把它所定义的对象置为顶层const
                ```
                constexpr int *np = nullptr;            // np是一个指向整数的常量指针，其值为空
                int j = 0;                              
                constexpr int i = 42;                   // i的类型是整型常量，i和j必须定义在函数体之外
                constexpr const int *p = &i;            // p是常量指针，指向整型常量i
                constexpr int *p = &j;                  // pl是常量指针，指向整数j
                ```
   7. 处理类型