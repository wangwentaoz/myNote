## 字符串、向量、数组
1. 序
   1. 除了上一章介绍的内置类型外，c++还定义了内容丰富的抽象数据类型库
      1. string和vector是两种最重要的标准类型库，前者支持可变长字符串，后者存放的是某种给定类型对象的可变长序列
      2. 迭代器是另一种标准类型库，是string和vector的配套类型，常被用于访问string中的字符或者vector中的元素
   2. 内置数组是一种更基础的类型，string和vector都是它的某种抽象
   3. 第二章介绍的内置类型是由c++直接定义的，体现了计算机硬件本身的能力
      1. 而标准库定义了另外一种具有更高级性质的类型，尚未直接实现在计算机硬件中
   4. 内置数组类型，和其他的一样，数组的实现与硬件密切相关
      1. 因此相较于string和vector，数组在灵活性上稍显不足
2. 命名空间的using声明
   1. 之前用到的库函数基本上都属于命名空间std
      1. std::cin 使用作用域操作符::从其左侧名字所示的作用域中寻找右侧哪个名字
   2. 可以使用更简单的方式使用命名空间中的成员：using声明
      1. 格式：using namespace::name;
      2. 一旦声明之后就可以直接使用命名空间中的名字
         ```
         using std::cin;
         int main(){
          cin >> i
         }
         ```
   3. 每个名字都需要独立的using声明
   4. 头文件不应该包含using声明
      1. 因为头文件的内容会拷贝到所有引用它的文件中
      2. 如果头文件中有某个using声明，那么每个使用该头文件的文件就都会有这个声明，可能会发生命名冲突
3. 标准库类型string
   1. 标准库类型string表示可变长的字符序列，使用前必须包含头文件
      ```
      #include <string>
      using std::string;
      ```
      1. 定义和初始化string对象
         1. 如何初始化类的对象是由类本身决定，string类的初始化方式：
           ```
           string s1 = 'faye';     拷贝初始化
           string s1(10, 'c');     直接初始化
           ```
         2. 如果提供了一个字符串字面值，则该字面值中除了最后的空字符外其他所有的字符都会被拷贝到新创建的string对象中
      2. 直接初始化和拷贝初始化
         1. 如果使用=初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中
         2. 如果不使用则执行的直接初始化
   2. string对象上的操作
      1. 类既能定义通过函数名调用的操作，也能定义<<,+等各种运算符在该类对象上的新含义
      2. 读写string对象，
         1. 会忽略开头的空白，例如"  hello world  " cin>>s 会读入hello
      3. 使用getline读取一整行
         1. 希望在最终读到的字符串中保留输入的空白符，这时应该使用getline函数替换原来的>>运算符
         2. getline函数的参数是一个输入流和一个string对象
         3. 从输入流读入直到遇到换行符为止，换行符也会被读入
         4. 如果直接读入换行符得到的结果是空string
         5. 结果返回它的流参数
           ```
           string line;
           while(getline(cin, line)){
              cout<<line<<endl;
           }
           line.size()
           ```
         6. 因为line不包括换行符，所以需要手动添加endl换行符结束当前行并刷新缓冲区
      3. string::size_type 类型
         1. line.size()函数返回的是一个string::size_type 类型的值
         2. string类及其他大多数标准库类型都定义了几种配套类型，size_type也是其中一种
         3. 它是一个无符号类型的值而且能足够放下任何string对象的大小
         4. 允许使用auto或者decltype推断变量的类型
           ```
           auto len = line.size()   // len的类型是string::size_type
           ```
         5. 因为返回值是无符号整型数，所以如果表达式混用了带符号数和无符号数会产生意想不到的效果
            1. 例如判断line.size() < n ,如果n是负值的int，结果一定为true，因为n会转换为比较大的无符号值
      4. 比较string对象
         1. ==和!=检验两个string对象是否相等，长度相同、字符完全相等才是相等
         2. <、>、>=、<=
            1. 如果两个string对象长度不等，而且短的每个字符都和长的对象对应位置上相等，则短的string对象小于较长的string对象
            2. 如果两个string对象某个位置上不一样，则比较结果是string对象中第一对相异字符比较的结果
      5. 字面值和string对象相加
         1. 当把string对象和字符字面值以及字符串字面值混在一条语句中使用时，必须确保加法运算符两侧的运算对象至少有一个是string
           ```
           string s2;
           string s3 = 'hello' + ',' + s2;  // 错误，不能把字面值直接相加
           ```
         2. c++中的字符串字面值并不是标准库类型string中的对象，他们是不同的类型
   3. 处理string对象中的字符
      1. 
4. 标准库类型vector