## 字符串、向量、数组
1. 序
   1. 除了上一章介绍的内置类型外，c++还定义了内容丰富的抽象数据类型库
      1. string和vector是两种最重要的标准类型库，前者支持可变长字符串，后者存放的是某种给定类型对象的可变长序列
      2. 迭代器是另一种标准类型库，是string和vector的配套类型，常被用于访问string中的字符或者vector中的元素
   2. 内置数组是一种更基础的类型，string和vector都是它的某种抽象
   3. 第二章介绍的内置类型是由c++直接定义的，体现了计算机硬件本身的能力
      1. 而标准库定义了另外一种具有更高级性质的类型，尚未直接实现在计算机硬件中
   4. 内置数组类型，和其他的一样，数组的实现与硬件密切相关
      1. 因此相较于string和vector，数组在灵活性上稍显不足
2. 命名空间的using声明
   1. 之前用到的库函数基本上都属于命名空间std
      1. std::cin 使用作用域操作符::从其左侧名字所示的作用域中寻找右侧哪个名字
   2. 可以使用更简单的方式使用命名空间中的成员：using声明
      1. 格式：using namespace::name;
      2. 一旦声明之后就可以直接使用命名空间中的名字
         ```
         using std::cin;
         int main(){
          cin >> i
         }
         ```
   3. 每个名字都需要独立的using声明
   4. 头文件不应该包含using声明
      1. 因为头文件的内容会拷贝到所有引用它的文件中
      2. 如果头文件中有某个using声明，那么每个使用该头文件的文件就都会有这个声明，可能会发生命名冲突
3. 标准库类型string
   1. 标准库类型string表示可变长的字符序列，使用前必须包含头文件
      ```
      #include <string>
      using std::string;
      ```
      1. 定义和初始化string对象
         1. 如何初始化类的对象是由类本身决定，string类的初始化方式：
           ```
           string s1 = 'faye';     拷贝初始化
           string s1(10, 'c');     直接初始化
           ```
         2. 如果提供了一个字符串字面值，则该字面值中除了最后的空字符外其他所有的字符都会被拷贝到新创建的string对象中
      2. 直接初始化和拷贝初始化
         1. 如果使用=初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中
         2. 如果不使用则执行的直接初始化
   2. string对象上的操作
      1. 类既能定义通过函数名调用的操作，也能定义<<,+等各种运算符在该类对象上的新含义
      2. 读写string对象，
         1. 会忽略开头的空白，例如"  hello world  " cin>>s 会读入hello
      3. 使用getline读取一整行
         1. 希望在最终读到的字符串中保留输入的空白符，这时应该使用getline函数替换原来的>>运算符
         2. getline函数的参数是一个输入流和一个string对象
         3. 从输入流读入直到遇到换行符为止，换行符也会被读入
         4. 如果直接读入换行符得到的结果是空string
         5. 结果返回它的流参数
           ```
           string line;
           while(getline(cin, line)){
              cout<<line<<endl;
           }
           line.size()
           ```
         6. 因为line不包括换行符，所以需要手动添加endl换行符结束当前行并刷新缓冲区
      3. string::size_type 类型
         1. line.size()函数返回的是一个string::size_type 类型的值
         2. string类及其他大多数标准库类型都定义了几种配套类型，size_type也是其中一种
         3. 它是一个无符号类型的值而且能足够放下任何string对象的大小
         4. 允许使用auto或者decltype推断变量的类型
           ```
           auto len = line.size()   // len的类型是string::size_type
           ```
         5. 因为返回值是无符号整型数，所以如果表达式混用了带符号数和无符号数会产生意想不到的效果
            1. 例如判断line.size() < n ,如果n是负值的int，结果一定为true，因为n会转换为比较大的无符号值
      4. 比较string对象
         1. ==和!=检验两个string对象是否相等，长度相同、字符完全相等才是相等
         2. <、>、>=、<=
            1. 如果两个string对象长度不等，而且短的每个字符都和长的对象对应位置上相等，则短的string对象小于较长的string对象
            2. 如果两个string对象某个位置上不一样，则比较结果是string对象中第一对相异字符比较的结果
      5. 字面值和string对象相加
         1. 当把string对象和字符字面值以及字符串字面值混在一条语句中使用时，必须确保加法运算符两侧的运算对象至少有一个是string
           ```
           string s2;
           string s3 = 'hello' + ',' + s2;  // 错误，不能把字面值直接相加
           ```
         2. c++中的字符串字面值并不是标准库类型string中的对象，他们是不同的类型
   3. 处理string对象中的字符
      1. 使用c++版本的c标准库头文件
         1. c++标准库中除了定义c++语言特有的功能外，也兼容了c语言的标准库
         2. c++头文件例如name.h，c++则将这些文件命名为cname
         3. 因此cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上更复合c++的要求
         4. 特别的，在名为cname的头文件定义名字从属于命名空间std，而定义在.h的头文件则不是
         5. 一般来说c++使用命名为cname的头文件，里面的变量都是std空间中，如果使用.h，就不得不考虑哪些是从c语言继承的，哪些是c++独有的
      2. 在cctype头文件中定义的一些方法
         1. islower(c)  isupper(c)  判断字符c的大小写
         2. tolower(c)  toupper(c)  转换为字符c的大小写形式
         3. isxdigit(c)  当c是十六进制数字时为真
      3. c++11新标准的范围for语句
         1. 遍历给定序列中的每一个元素并对每个值执行某种操作
           ```
           for(declaration: expression)
              statement
           ```
            1. expression部分是一个对象，用于表示一个序列
            2. declaration负责定义一个变量，被用于访问序列的元素
         2. 例
           ```
           string str("some string");
           for (auto c : str)
                cout << e << endl;
         3. 使用范围for修改字符串中的字符
            1. 这时必须把循环变量定义变成引用类型
            2. 当使用引用时，这个变量实际上依次被绑定到序列的每个元素上，使用这个引用我们就能改变它绑定的字符
            3. 例：
              ```
              string s("Hello World!");
              for (auto &c :s)                 // c 是引用
                c = toupper(c);
              cout << c << endl;
              ```
      4. 只处理一部分字符
         1. 访问string中的单个字符有两种方式：一种使用下标，另一种使用迭代器
         2. 下标运算符[]接受的输入参数是string::size_type类型的值
            1. 如果某个索引是带符号类型的值将会自动转换为由string::size_type表达的无符号类型
            2. 使用下标执行迭代
            ```
            for (decltype(s.size()) index = 0 ; index != s.size() && !isspace(s[index]) ; ++index) 
              s[index] = toupper(s[index]) ;
            ```
4. 标准库类型vector
   1. 标准库vector表示对象的集合，其中所有对象的类型都相同
      1. 集合中每个对象都有与之对应的索引，用于访问对象
      2. 想要使用vector，必须声明头文件
        ```
        #include <vector>
        using std::vector;
        ```
      3. c++既有类模板，也有函数模板，其中vector是一个类模板
      4. 模板本身不是类或函数，可以把模板看作为编译器生成类或函数编写的一份说明
      5. 编译器根据模板创建类或函数的过程称为实例化
   2. 对于类模板，通过提供一些额外信息来指定模板实例化
      1. 例：
        ```
        vector<int> ivec;                        //  ivec保存int型的对象
        vector<Sales_item> Sales_vec;            //  Sales_vec保存Sales_item型的对象
        vector<vector<string>> file;             //  该向量的元素是vector对象
        ```
      2. vector能容纳绝大多数类型的对象作为其元素，因为引用不是对象，所以不存在包含引用vector
      3. 某些老的编译器要求如果vector的元素还是vector元素，则在右侧必须要加空格 `vector<vector<string> >`
   3. 定义和初始化vector对象
      1. vector模板控制着定义和初始化向量的方法
        ```
        vector<T> v1                     v1是一个空vector，它潜在的元素都是T类型的，执行默认初始化
        vector<T> v2(v1)                 v2中包含有v1所有元素的副本，执行的拷贝操作
        vector<T> v2 = v1                等价于v2(v1)
        vector<T> v3(n,val)              v3包含n个重复的元素，每个元素的值都是val
        vector<T> v4(n)                  v4包含n个重复执行了值初始化的对象
        vector<T> v5{a,b,c}              v5包含初始值个数的元素，每个元素被赋予相应的初始值
        vector<T> v5 = {a,b,c}           同v5{a,b,c}   
        
        vector<string> svec; //默认初始化，svec不含任何元素
        ```
      2. 列表初始化vector对象(v5)
         1. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化对象，而不能放到圆括号
      3. 值初始化(v4)
         1. 可以只提供vector元素的数量不用略去初始值，此时库会创建一个值初始化的元素初值
            1. 如果vector对象的元素是内置类型，比如int型会被初始化为0，string型会被初始化为空
         2. 特殊限制
            1. 有些类型要求必须明确的提供初始值，参考2.2.1
            2. 如果只提供了元素的数量没有设定初始值，只能使用直接初始化
         3. 例
            ```
            vector<int> ivec(10);   10个元素，每个都初始化为0
            vector<int> vi = 10;    错误，必须使用直接初始化的形式指定向量大小，本意是创建10个值初始化的元素vector对象，而非把数字10拷贝到vector中
            vector<string> v1("Hi");       错误
            vector<string> v2{10, "Hi"};   10个hi字符串
            ```
         4. 列表初始值还是元素数量？
            1. 通过使用花括号圆括号来区分数字的含义
            2. 如果使用圆括号，提供的值是用来构造vector对象的
            3. 如果用的花括号，可以表述为我们想列表初始化该vector对象
            4. 如果使用花括号的形式但是提供的值不能列表初始化，那么就是使用默认值构造vector对象
   4. 向vector对象中添加元素
      1. vector的成员函数push_back向其中添加元素
         1. 例：把读取的元素存入
            ```
            string word;
            vector<string> text;
            while(cin >> word){
              text.push_back(word);
            }
            ```
         2. c++允许vector能在运行时高效快速的添加元素，最有效的方法是定义一个空vector，然后往里面添加元素
         3. c语言和java与之不同，在创建vector对象时顺便指定其内容是最好的
      2. 如果循环体内部包含向vector对象添加元素，则不能使用范围for循环，具体原因见5.4.3
   5. 其他vector操作
      1. 大多和string的操作相似
        ```
        v.empty()        判断是否不含有任何元素
        v.size()         返回的类型是由vector定义的size_type类型 vector<int>::size_type，需指明它由那种类型定义的
        v[n]
        v1 == v2         v1、v2相等当且仅当他们的元素数量相同且对应位置的元素值也相同
        <,<=,>,>=        以字典顺序进行比较，和string类型一样
        ```
         1. 只有当元素的值可比较时，vector对象才可以被比较，比如`vector<string>`类型可以比较，`vector<Sales_item>`类型就不可以比较
      2. 计算vector内对象的索引
         1. 只要vector对象不是一个常量，就能向下标运算符返回的元素赋值
      3. 不能用下标形式添加元素，只能对已知且存在的元素执行下标操作，正确方法是用push_back
         1. 缓冲区溢出 buffer overflow 就是这类错误
5. 迭代器
   1. 除了vector标准库还定义的其他集中容器
      1. 所有标准库容器都可以使用迭代器，但是只有集中容器支持下标运算符
      2. string对象严格来说不属于容器类型，但是其支持许多和容器类型相似的操作
      3. 类似于指针类型，迭代器也提供了对对象的间接访问
      4. 迭代器分为有效和无效，类似指针
         1. 有效的迭代器指向某个元素，或者指向容器中尾元素的下一位置
         2. 其他情况都是无效
   2. 使用迭代器
      1. 有迭代器的类型 同时拥有返回迭代器的成员
         1. 比如都有名为begin和end的成员
         2. begin返回指向第一个成员的迭代器
         3. end返回指向容器尾元素的下一位置的迭代器，即指向容器本不存在的尾后元素，也被称为尾后迭代器、尾迭代器
            1. 并没有实际意义，表示我们已经处理完容器中的所有元素
            2. 容器为空则begin和end返回的是同一个迭代器
         4. 我们并不清楚、不在意迭代器的准确类型，所以使用auto
           ```
           auto b = v.begin() b表示v的第一个元素
           ```
      2. 迭代器运算符
         ```
         *iter                         返回迭代器iter所指元素的引用
         iter->mem                     解引用iter并获取该元素名为men的成员，等价于(*iter).mem
         ++iter                        令iter指向下一个元素
         iter1 == iter2                判断两个是否相等，如果指向的都是尾后迭代器也相同
         ```
         1. 例：把string对象第一个字符改为大写形式
           ```
           string s("some string")
           if(s.begin() != s.end()){
             auto it = s.begin()
             *it = toupper(*it)
           }
           ```
      3. 迭代器类型
         1. 就像不知道string和vector的size_type成员是什么类型，一般来说我们也不需要知道迭代器的准确类型
         2. 拥有迭代器的标准库类型使用iterator和const_iterator表示迭代器的类型
           ```
           vector<int>::iterator it;                it能读写vector<int>的元素
           string::iterator it2;                    it2能读写string的元素
           vector<int>::const_iterator it3;
           string::const_iterator it4;
           ```
         3. 如果vector对象或者string对象是一个常量，则只能使用const_iterator
      4. begin和end运算符
         1. 返回的具体类型由对象是否为常量决定，如果是常量返回的类型就是const_iterator
           ```
           vector<int> v;
           const vector<int> cv;
           auto it1 = v.begin();     it1类型为vector<int>::iterator
           auto it3 = v.cbegin();     it3类型为vector<int>::const_iterator
           auto it2 = cv.begin();    it2类型为vector<int>::const_iterator
           ```
         2. 如果对象只需要读操作最好使用常量类型，比如it1，所以c++11引入两个新函数确保返回的是const_iterator类型
            1. cbegin
            2. cend
      5. 结合解引用和成员访问操作
         1. 解引用可以获取迭代器所指的对象，如果该对象的类型是类，那么就可以进一步访问其成员
         2. 例如解引用字符串判断其是否为空
           ```
           (*it).empty()
           ```
            1. 注意，前面的圆括号不可以省略，如果省略，.运算符由it来执行而非it解引用的结果，又因为it是迭代器所以会报错
      6. 某些对vector对象的操作会使迭代器失效
         1. 虽然vector可以动态增长，但是会有副作用
         2. 第一个限制是不能在范围for中向vector中添加元素
         3. 另一个限制是任何一个可能改变vector对象容量的操作，比如push_back，都会使其迭代器失效，9.3.6将详细讨论
   3. 迭代器运算
      1. string和vector的迭代器提供更多额外的运算符，被称为迭代器运算
        ```
        iter + n                       迭代器加整数仍得到迭代器，相当于迭代器向前移动n个位置，或者指向某个元素，或者指向容器尾元素的下一个位置
        iter1 += n                     迭代器加法的复合赋值语句，将iter1 + n 的结果赋值给iter1
        iter1 - iter2                  迭代器向减得到他们之间的距离，类型为difference_type的带符号整数
        > >= < <=                      判断两个迭代器指向的位置大小，必须合法且指向同一个容器的元素
        ```
6. 数组
   1. 数组是一种类似于标准库类型vector的数据结构
      1. 数组也是存放类型相同的对象的容器
      2. 但是数组的大小确定不变，不能随意向其中增加元素
   2. 定义和初始化内置数组
      1. 声明形式为a[d] ,其中a是数组名字，d是数组维度，必须为常量表达式
        ```
        unsigned cnt = 42;
        string bad[cnt];   错误，cnt不是常量表达式
        ```
         1. 数组的元素会被默认初始化
         2. 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值
         3. 定义数组时必须指明其类型，不可以使用auto推断
         4. 和vector一样，数组的元素应为对象，不可能是引用
      2. 显示初始化数组元素
         1. 可以对数组进行列表初始化，此时允许忽略其维度
            ```
            int a3[5] = {0, 1, 2}       等价于         int a3[5] = {0, 1, 2， 0， 0}  
            ```
      3. 字符数组的特殊性
         1. 可以使用字符串字面值对数组进行初始化
            ```
            char a1[] = {'c', '+', '+', '\0'}       等价于         char a1[] = "c++"
            ```
         2. 注意字符串字面值结尾有一个空字符，这个空字符也会被拷贝到数组中
      4. 不允许拷贝和赋值
         1. 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值
            ```
            int a[] = {0, 1, 2}
            int a2 = a                错误
            a2 = a                    错误
            ```
      5. 理解复杂的数组声明
            ```
            int *ptrs[10];                            ptrs是含有十个整型指针的数组
            int &refs[10];                            错误，不存在引用的数组
            int (*Parry)[10] = &arr;                  Parry指向一个含有10个整数的数组
            int (&arrRef)[10] = arr;                  arrRef引用一个含有10个整数的数组

            int *(&arry)[10] = ptrs;                  arry是数组的引用，该数组含有10个指针
            ```
         1. 默认情况下，类型修饰符是从右向左一次绑定，例如对于ptrs，首先是一个大小为10的数组，然后知道其中存放的是指向int指针
   3. 访问数组元素
      1. 在使用数组下标时，其类型为size_t类型，是一种机器相关的无符号类型
         1. 在cstddef头文件中定义了size_t类型，这个文件是c标准库stddef.h头文件的c++语言版本
      2. 数组除了大小固定外，其他用法和vector基本类似
      3. 检查下标的值是否越界
   4. 指针和数组
      1. 