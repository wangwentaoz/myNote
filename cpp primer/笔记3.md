## 第四章 表达式
1. 基础
   1. 重载运算符
      1. 当运算符作用于类类型的运算对象时，用户可以自行定义其含义，称之为重载运算符
   2. 左值和右值
      1. 左值位于赋值语句的左侧，右值则不能
      2. 一个左值表达式的求值结果是一个对象或者一个函数
         1. 然而某些以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象
         2. 虽然某些表达式的求值结果是对象，但他们是右值并非左值
      3. 当一个对象被用作右值的时候，用的对象是值；当对象被用作左值的时候，用的对象是身份（在内存中的位置）
      4. 需要右值的地方可以使用左值替代，但是不能把右值当成左值使用
      5. 左值
         1. 赋值运算需要左值作为其左侧运算对象，得到的结果仍是左值
         2. 取地址符作用于左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值
         3. 内置解引用运算符，下标运算符，迭代器解引用运算符，string和vector的下标运算符的求职结果都是左值
         4. 内置类型和迭代器的递增递减运算符作用域左值运算对象，所得的结果也是左值
      6. 使用关键字decltype
         1. 如果表达式求值结果是左值，得到一个引用类型
            1. p的类型是 int* ,* p使用解运算符生成左值，所以decltype(* p) 的结果是int&
            2. 因为取地址符得到的是右值，所以decltype(&p)的结果是 int **
   3. 优先级和结合律
      1. 高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密结合在一起
         1. 如果优先级相同，则其组合规律由结合律确定
      2. 括号无视优先级和结合律
   4. 求值顺序 
      1. 在大多情况下并不会指明求值顺序
         1. 例：我们并不知道是f1先运算还是f2先运算
          ```
          int i = f1() * f2();
          ```
         2. 所以如果表达式指向并修改了同一对象，将会引发错误并产生未定义的行为
          ```
          int i = 0;
          cout << i << i++ << endl;
          // 程序是未定义的，结果可能是1 1，也可能是0 1，不知道i++的计算时间
          ```
      2. 有四种运算符规定了运算顺序
         1. &&  只有左侧为真才计算右侧的值
         2. || 
         3. ？|   条件运算符
         4. ，    逗号运算符
2. 算术运算符 
   1. 一元运算符的优先级最高( + - )，然后乘除取余，最后加减，所有运算符都满足左结合律
   2. 算术运算符的运算对象和求值结果都是右值
   3. 在表达式求值之前，小整型类型的运算对象被提升成较大的整数类型，所有运算对象最终都会被转为同一种类型
   4. 一元正号运算符、加法运算符、减法运算符都可以作用于指针，当一元正号运算符作用于指针或者算术值后返回运算对象值的一个提升后的副本
      ```
      bool b = true;
      bool b2 = -b;   b2是true，布尔类型的运算对象将被提升为int型，所以b会被提升成整数值1，然后变为-1，-1转为bool值时由于其不是0，所以转成bool值为1，所以b2是真
      ```
   5. 运算符%称为取余或者取模运算，参与取余运算的运算对象必须是整数类型
      ```
      (-m) / n = m / (-n) = - (m/n)
      // 如果 m%n 的结果不为0，则其符号和m相同
      m % (-n) = m % n
      (-m) % n = -(m % n)
      ```
3. 逻辑和关系运算符
   1. 逻辑运算符
      1. && ： 当且仅当两个运算对象都为真时结果为真
      2. || ： 只要两个运算对象中的一个是真结果就为真
      3. 这两个运算符都是先求左侧运算对象的值，如果可以直接判断结果则右侧运算对象不求值
   2. 比较
      ```
      if(val)     val为非0值，结果为真
      if(val == true)      val等于1，结果为真，会先把true转为1然后再比较
      ```
4. 赋值运算符
   1. 赋值运算符的左侧运算对象必须是一个可以修改的左值
   2. 赋值运算的结果是它的左侧运算对象，并且是一个左值
      1. 如果左右两侧运算对象的类型不同，则右侧运算对象将转换成左侧运算对象的类型
   3. c++11允许使用花括号括起来的初始值列表作为赋值语句的左侧运算对象，称为列表初始化
      ```
      int k;
      k = {3.14};        // 错误，窄化转换 p39详细解释
      vector<int> vi;
      vi = {1, 2, 3};
      ```
      1. 如果左侧运算对象是内置类型，那么初始值列表只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间
      2. 对于类类型，赋值运算细节由类本身决定
   4. 赋值运算满足右结合律
   5. 赋值运算符优先级较低
   6. 复合赋值运算符
      1. 比如 += 、 -= 等等
      2. 和a = a + x 的区别在于左侧运算对象的求值次数，影响可以忽略不计
5. 递增和递减运算符
   1. 即对象的减1和加1
   2. 两种形式：
      1. 前置版本：首先将运算对象减1和加1，然后将改变后的对象本身作为左值返回
      2. 后置版本：也会将运算对象减1和加1，将对象原始值的副本(运算对象改变之前的那个值)作为右值返回
   3. 必须作用于左值运算对象
   4. 除非必须，否则不使用后置版本，会造成性能浪费
6. 成员访问运算符
   1. 表达式 ptr -> mem 等价于 (*ptr).mem
      1. 因为解运算符的优先级低于点运算符，所以必须加括号
7. 条件运算符
   1. (cond ? expr1 : expr2;)允许我们把简单的if-else逻辑嵌入到单个表达式中
   2. 条件运算符的优先级特别低
      ```
      cout << ((grade  < 60) ? "fail" : "pass");          // 输出pass或fail
      cout << (grade  < 60) ? "fail" : "pass";            // 输入0或1，等于cout << (grade  < 60) 和 cout ? "fail" : "pass";  这两条语句
      cout << grade < 60 ? "fail" : "pass";               // 错误，试图比较cout和60
      ```
8. 位运算符
   1. 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合
      ```
      `    ：位求反
      <<   ：左移
      >>   ：右移
      &    ：位与
      ^    ：位异或
      |    ：位或
      ```
      1. 运算对象可以是带符号的，也可以不带符号，如果是负值，位运算如何处理它的符号位依赖于机器，可能改变符号位的值
      2. 建议不要使用位运算处理带符号类型
   2. 位移运算符
      1. 右侧运算对象(即移动的位数)一定不能为负，而且值必须严格小于结果的位数，移出边界之外的位要被舍弃了
        ```
        unsigned char bits = 0233;     八进制字面值，表示为二进制为  10011011
        bits << 8;                     bits提升为int类型，然后左移8位   00000000 00000000 10011011 00000000
        bits >> 3;                     bits提升为int类型，然后右移3位   00000000 00000000 00000000 00010011
        ```
      2. char类型进行位运算首先会被提升为int类型，高位补0
   3. 位移运算符满足左结合律
      1. 位移运算符的优先级比算术运算符优先级低，但是比关系运算符、赋值运算符和条件运算符高
9. sizeof运算符
   1. sizeof运算符返回一条表达式或一个类型名字所占的字节数
      1. 满足右结合律，所得到的值是一个size_t类型的常量表达式
      2. 如果是表达式的话，sizeof并不实际计算其运算对象的值，所以如果 sizeof *p 中p是无效指针，也不会有影响，因为指针并没有被使用，sizeof不需要真的解引用指针也能知道它所指的对象类型
   2. sizeof运算符结果部分依赖于其作用的类型
      1. 对char或者类型为char的表达式执行sizeof运算得到1
      2. 对指针执行sizeof运算得到指针本身所占空间的大小
      3. 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效
      4. 对数组执行sizeof得到数组中所有元素各执行sizeof运算然后求和
      5. 对string对象或者vector对象执行sizeof运算只返回改类型固定部分的大小，不会计算对象中的元素占用多少空间
10. 逗号运算符
    1. 按照从左向右的顺序依次对逗号运算符的两个运算对象求值
    2. 表达式的结果是右侧表达式的值
11. 类型转换
    1. 如果两种类型可以相互转换，那么他们之间就是相关联的
    2. 